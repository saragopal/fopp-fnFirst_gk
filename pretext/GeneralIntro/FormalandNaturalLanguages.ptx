<?xml version="1.0"?>
<section xml:id="general-intro_formal-and-natural-languages">
  <title>Formal and Natural Languages</title>
  <p><term>Natural languages</term> are the languages that people speak, such as English,
            Spanish, Korean, and Mandarin Chinese. They were not purposely designed by people (although people have tried to
            impose some order on them); they evolved naturally.</p>
  <p><term>Formal languages</term> are languages that are designed by people for specific
            applications. For example, the notation that mathematicians use is a formal
            language that is particularly good at denoting relationships among numbers and
            symbols. Chemists use a formal language to represent the chemical structure of
            molecules. And most importantly:</p>
  <blockquote>
    <p>
      <alert>Programming languages are formal languages that have been designed to
                    express computations.</alert>
    </p>
  </blockquote>
  <p>Formal languages tend to have strict rules about syntax. For example, <c>3 + 3 = 6</c>
            is a syntactically correct mathematical statement, but <c>3 = + 6 $</c> is not.
            H&#8322;O is a syntactically correct chemical name, but &#8322;Zz is
            not.</p>
  <p>Syntax rules come in two flavors, pertaining to <term>tokens</term> and <term>structure</term>.
            Tokens are the basic elements of the language, such as words, numbers, and
            symbols. One of the problems with <c>3 = + 6 $</c> is that the symbol <c>$</c> is not a
            legal token in mathematics (at least as far as we know). Similarly,
            &#8322;Zz is not legal in chemistry because there is no element with the abbreviation
            <c>Zz</c>.</p>
  <p>When you read a word in English, you have to make sure the tokens are correct and appropriate.
  Humans are quite good at figuring out the tokens despite their many variations as seen by our ability to read various fonts, bumper stickers,
  and Internet spellings (e.g.: &#945;, &#8704;, and <em>a</em> are all recognizable as the letter a; the text 'e5c4p3' can be read as 'escape').</p>

  <p>The second type of syntax rule pertains to the <term>structure</term> of a statement&#x2014;
            that is, the way the tokens are arranged. The statement <c>3 = + 6 $</c> is
            structurally illegal because you can't place a plus sign immediately after an
            equal sign.  Similarly, molecular formulas have to have subscripts after the
            element name, not before.</p>
  <p>When you read a sentence in English or a statement in a formal language, you
            have to figure out what the structure of the sentence is (although in a natural
            language you do this subconsciously). This process is called <term>parsing</term>. 
            For example, when you hear the sentence, <q>The other shoe fell</q>, you understand
            that the other shoe is the subject and fell is the verb.  Once you have parsed
            a sentence, you can figure out what it means &#x2014; the <term>semantics</term> of the sentence.
            Assuming that you know what a shoe is and what it means to fall, you will
            understand the general implication of this sentence.</p>

  <p>People who grow up speaking a natural language&#x2014;that is, everyone&#x2014;often have a hard
            time adjusting to formal languages like computer programing languages. Although formal and natural languages 
            have many features in common &#x2014; tokens,
            structure, syntax, and semantics &#x2014; there are many differences:</p>
  <dl>
    <li>
      <title>ambiguity</title>
      <p>Natural languages are full of ambiguity, which people deal with by
                            using contextual clues and other information.</p>
      <p>Formal languages are designed to be nearly or completely unambiguous, which means that any
                            statement has exactly one meaning, regardless of context.</p>
      <p>For example, in a natural language, someone may be 'tall' for their age. However in a
                          a formal language like Python, <c>tall = True</c> has one meaning.</p>
    </li>
      <li>
      <title>literalness</title>
      <p>Formal languages mean exactly what they say; in Python we code <c>height = 192.6</c>. On the other hand,
                            natural languages are full of idiom and metaphor. If someone says, <q>How's the
                            weather up there?</q> we can assume they are implying the other person is 
                            so tall that they must experience a different weather at their head's elevation.</p>
      </li>
  </dl>

  <p>Here are some suggestions for reading programs (and other formal languages):</p>
  <ol marker="a">
<li>
  <p>
    Remember that formal languages are much more dense than natural languages. It takes longer to read them and little inconsistencies in spelling and punctuation, 
          which you can get away with in natural languages, will make a big difference in a formal language. <alert>Practice paying extra attention to all the tokens.</alert>
  </p>
</li>
<li>
  <p>
    Recognize that structure is very important, and is usually quite consistent, in formal languages. Always start reading a formal language from top to bottom but 
        make note of indentations (it really matters) and other ways the program's flow will be modified.
          Recognize that some instructions will be executed but not others (conditional execution) or that some actions will happen more than once (repetition). Learn to
          to identify these kinds of structures, the algorithm's parts and the program's overall flow. <alert>Learn to see, identify, and use common
          programming structures.</alert>
  </p>
</li>
<li>
  <p>It bears repeating, computers will do only what you tell them to do and nothing more. They do not 'understand' your intentions. 
  In later chapters we will discuss how to make 'self-documenting' code that makes your programing intentions plainer to others reading your code,
  but <alert>always be ready to parse the program to understand what the code is actually doing and not what you assume it ought to do.</alert>    
  </p>
</li>

  </ol>


  <p>
    <term>Check your understanding</term>
  </p>
  <exercise label="question1_6_1">
    <statement>
      <p>The differences between natural and formal languages include:</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>natural languages can be parsed while formal languages cannot.</p>
        </statement>
        <feedback>
          <p>Actually both languages can be parsed (determining the structure of the sentence), but formal languages can be parsed more easily in software.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>ambiguity and literalness.</p>
        </statement>
        <feedback>
          <p>Both of these can be present in natural languages, but cannot exist in formal languages.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>there are no differences between natural and formal languages.</p>
        </statement>
        <feedback>
          <p>There are several differences between the two but they are also similar.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>tokens, structure, syntax, and semantics.</p>
        </statement>
        <feedback>
          <p>These are the similarities between the two.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="question1_6_2">
    <statement>
      <p>True or False:  Reading a program is like reading other kinds of text.</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>True</p>
        </statement>
        <feedback>
          <p>It usually takes longer to read a program because the structure is as important as the content and must be interpreted in smaller pieces for understanding.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>False</p>
        </statement>
        <feedback>
          <p>It usually takes longer to read a program because the structure is as important as the content and must be interpreted in smaller pieces for understanding.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
</section>
